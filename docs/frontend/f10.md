---
outline: deep
---

# Оптимізація та тестування в React

## Профілювання додатків
Профілювання додатків - це процес збору та аналізу даних про роботу програмного забезпечення з метою виявлення і вирішення проблем ефективності, швидкодії та інших аспектів, які можуть впливати на продуктивність або коректність роботи додатку. Ось ключові аспекти профілювання додатків:

### Що таке профілювання додатків?

Профілювання додатків - це процес збору, аналізу та інтерпретації даних про виконання програмного забезпечення. Цей процес дозволяє ідентифікувати місця, де можна покращити продуктивність, виявити витоки пам'яті, знайти дефекти або оптимізувати роботу програми.

### Основні цілі профілювання:

1. **Покращення продуктивності**: Виявлення та усунення місць зайвого споживання ресурсів, оптимізація часу виконання або покращення швидкодії.

2. **Виявлення витоків пам'яті**: Виявлення та виправлення проблем, пов'язаних із некоректним використанням пам'яті, таких як утечки пам'яті або недосяжні об'єкти.

3. **Покращення коректності програми**: Виявлення і виправлення дефектів, які можуть призводити до некоректної роботи або відмов програми.

4. **Оптимізація ресурсів**: Виявлення та усунення бутланів, які можуть впливати на ефективне використання процесорного часу, пам'яті або інших ресурсів.

### Інструменти профілювання:

- **Profiler в браузері**: Інструменти розробника у сучасних веб-браузерах, такі як Chrome DevTools або Firefox Developer Tools, дозволяють відслідковувати час виконання JavaScript, аналізувати виклики функцій та знаходити проблеми з пам'яттю.

- **Профілери для мов програмування**: Багато мов програмування мають вбудовані чи сторонні інструменти для профілювання, які дозволяють аналізувати час виконання, витрати пам'яті та інші метрики ефективності.

- **Інструменти для аналізу витоків пам'яті**: Спеціалізовані інструменти, такі як Valgrind для C/C++ або Memory Profiler для Java, дозволяють виявляти та виправляти проблеми з витоками пам'яті.

### Загальний процес профілювання:

1. **Збір даних**: Вимірювання часу виконання, споживання пам'яті, виклики функцій та інші метрики виконання програми.

2. **Аналіз результатів**: Оцінка зібраних даних для ідентифікації гарячих точок (бутланів), місць зайвого споживання ресурсів або потенційних проблем з пам'яттю.

3. **Оптимізація і усунення проблем**: Внесення змін у код програми з метою покращення продуктивності, ефективності та коректності роботи.

Профілювання додатків є важливою складовою розробки програмного забезпечення, що дозволяє покращити якість та ефективність програм, зменшити витрати ресурсів і підвищити задоволення користувачів.


## Unit-тести
Зазвичай при розробці React-застосунків використовуються різні підходи для написання unit-тестів, що дозволяють перевіряти правильність роботи компонентів і логіки програми. Ось кілька загальних підходів та інструментів, які використовують для цього:

1. **Jest**: Це один з найпоширеніших фреймворків для тестування JavaScript, який часто використовується для тестування React-коду. Він підтримує автоматичну підстановку і мокування, що дозволяє створювати імітовані об'єкти та функції для тестування.

2. **React Testing Library**: Це бібліотека для тестування React-компонентів, яка забезпечує зручний API для взаємодії з компонентами, як це робить користувач. Вона спрощує написання тестів, які відповідають реальному способу взаємодії користувачів з додатком.

3. **Enzyme**: Це ще один популярний інструмент для тестування React-компонентів, який надає різні методи для зручного тестування вмісту компонентів, їх станів і взаємодії.

4. **Концепції тестування**: При написанні unit-тестів для React-застосунків важливо тестувати як можливо більше компонентів і їх взаємодій, перевіряти, чи правильно вони рендеряться, чи коректно працюють їх обробники подій, чи відображаються очікувані дані тощо.

5. **Mocking і взаємодія з API**: Для тестування компонентів, які взаємодіють з API, часто використовуються імітатори (mocks) для симуляції відповідей API і забезпечення контрольованої взаємодії.

Це лише загальні підходи і інструменти, які використовуються для написання unit-тестів у React-застосунках. Конкретний вибір залежить від потреб проекту та особистих вподобань розробника.

## Integration-тести
Integration-тести в контексті розробки програмного забезпечення використовуються для перевірки взаємодії між різними компонентами або модулями програми, щоб переконатися, що вони працюють разом правильно. У веб-розробці, зокрема у React-застосунках, integration-тести зазвичай охоплюють наступні аспекти:

### Що таке integration-тести?

Integration-тести (інтеграційні тести) перевіряють, як добре різні компоненти програми взаємодіють між собою. Основна мета - переконатися, що компоненти, які працюють окремо, працюють разом правильно.

### Особливості integration-тестів у React:

1. **Тестування взаємодії компонентів**: Перевірка, як компоненти реагують на взаємодію один з одним при їх спільній роботі в контексті реального або симульованого середовища.

2. **Загальна поведінка програми**: Перевірка, як взаємодіють окремі частини програми, включаючи взаємодію з API, обробку даних, відображення і т.д.

3. **Mocking**: Використання імітаторів (mocks) для симуляції зовнішніх ресурсів, таких як серверні запити або бази даних, щоб забезпечити контрольоване середовище для тестування.

4. **Стандартні сценарії взаємодії**: Тестування типових сценаріїв взаємодії між компонентами, які можуть включати перехід між сторінками, обмін даними через пропси або контекст, обробку подій і т.д.

5. **Інтеграція з внешніми бібліотеками**: Перевірка, як компоненти взаємодіють з сторонніми бібліотеками або фреймворками, якщо такі використовуються у проекті.

### Інструменти для integration-тестування в React:

- **Jest** в поєднанні з **React Testing Library** або **Enzyme**: Ці інструменти дозволяють легко писати і запускати integration-тести для React-компонентів, перевіряючи їх взаємодію та відповідність очікуваним результатам.

- **Засоби браузера**: Інтеграційне тестування також можна проводити за допомогою автоматизації браузерних тестів (наприклад, за допомогою Selenium або Puppeteer), які можуть симулювати дії користувачів і перевіряти поведінку додатків у реальному середовищі.


Integration-тести дозволяють перевіряти великі частини програми в цілому, виявляти проблеми взаємодії між компонентами і забезпечувати відповідність очікуваним функціональним вимогам. Це важливий етап розробки, який допомагає забезпечити стабільність і надійність React-застосунків.




## Тестування Redux
Тестування Redux включає перевірку правильності роботи всіх основних аспектів управління станом, які забезпечує Redux, включаючи дії (actions), редуктори (reducers) і складові стану (state). Ось основні аспекти тестування Redux:

1. **Тестування дій (actions)**:
   - Перевірка, що дії Redux правильно створюються і їх властивості відповідають очікуванням.
   - Використання Jest або інших фреймворків для тестування JavaScript для написання тестів на дії.

2. **Тестування редукторів (reducers)**:
   - Перевірка, що редуктори коректно обробляють дії і змінюють стан за очікуваннями.
   - Написання unit-тестів для редукторів, які передають вхідні дані і перевіряють вихідний стан.

3. **Інтеграційне тестування зі станом (state)**:
   - Перевірка взаємодії різних частин Redux-статусу між собою.
   - Тестування, що компоненти правильно взаємодіють зі станом через mapStateToProps і mapDispatchToProps.

4. **Тестування міжкомпонентного взаємодії**:
   - Перевірка, що компоненти правильно виконують дії із зміни стану із Redux-статусом.
   - Інтеграційне тестування з використанням Jest, React Testing Library або Enzyme.

5. **Модульне тестування селекторів (selectors)**:
   - Перевірка, що селектори, які використовуються для вибору частини стану, повертають очікувані значення.
   - Юніт-тестування селекторів для забезпечення їх коректної роботи.

6. **Тестування middleware** (проміжники):
   - Якщо використовуються middleware Redux (наприклад, для асинхронних дій), перевірка, що вони коректно обробляють дії та взаємодіють зі станом.

Ці підходи дозволяють забезпечити високу якість коду Redux-застосунків і зменшити ймовірність помилок у процесі розробки.


## Тестування асинхронного коду

Асинхронний код є дуже поширеним в JavaScript. Коли у вас є код, який працює асинхронно, Jest повинен знати, коли код, що тестується, закінчив свою роботу перед тим, як перейти до наступного тесту. Jest дозволяє це зробити кількома способами:

1. **Проміси**:
   Просто поверніть проміс з вашого тесту, і Jest буде чекати, поки він виконається. Наприклад:

    ```javascript
    test('the data is peanut butter', () => {
      return fetchData().then(data => {
        expect(data).toBe('peanut butter');
      });
    });
    ```

2. **Async/Await**:
   Ви можете використовувати `async` та `await` у ваших тестах. Наприклад:

    ```javascript
    test('the data is peanut butter', async () => {
      const data = await fetchData();
      expect(data).toBe('peanut butter');
    });

    test('the fetch fails with an error', async () => {
      expect.assertions(1);
      try {
        await fetchData();
      } catch (error) {
        expect(error).toMatch('error');
      }
    });
    ```

3. **Зворотні виклики (Callbacks)**:
   Якщо ви не використовуєте проміси, то ви можете скористатися колбеками. Наприклад:

    ```javascript
    test('the data is peanut butter', () => {
      function callback(error, data) {
        if (error) {
          throw error;
        }
        expect(data).toBe('peanut butter');
      }
      fetchData(callback);
    });
    ```

Не забудьте завжди переконатися, що ви повертаєте проміс (або використовуєте `await`). Якщо ви очікуєте, що проміс буде відхилено, використовуйте метод `.catch`. Також додайте `expect.assertions`, щоб переконатися, що певна кількість перевірок була виконана.


```javascript
// Приклад асинхронної функції для тестування
async function fetchData() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  return data;
}
```

## Тестування роутингу

Перевірте, чи компоненти, які відповідають роутам, відображаються на сторінці. Використовуйте `render` з React Testing Library або `shallow` з Enzyme для створення віртуального DOM і перевірки наявності необхідних елементів.

```javascript
import { render } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import MyRoutes from './MyRoutes'; // ваші роути

test('renders home route', () => {
  const { getByText } = render(
    <MemoryRouter initialEntries={['/']}>
      <MyRoutes />
    </MemoryRouter>
  );
  const homeElement = getByText(/Welcome to our app/i);
  expect(homeElement).toBeInTheDocument();
});
```

### Тестування переходів між роутами

Перевірте, чи роутинг працює коректно, переходячи між різними роутами. Використовуйте `history` з React Router для перевірки URL.

```javascript
import { render, fireEvent } from '@testing-library/react';
import { createMemoryHistory } from 'history';
import { Router } from 'react-router-dom';
import MyRoutes from './MyRoutes'; // ваші роути

test('navigates to about page', () => {
  const history = createMemoryHistory();
  const { getByText } = render(
    <Router history={history}>
      <MyRoutes />
    </Router>
  );

  fireEvent.click(getByText(/About/i));
  expect(history.location.pathname).toBe('/about');
});
```

### Тестування передачі параметрів

Якщо ви використовуєте динамічні роути з параметрами, перевірте, чи вони передаються правильно.

```javascript
import { render } from '@testing-library/react';
import { MemoryRouter, Route } from 'react-router-dom';
import MyRoutes from './MyRoutes'; // ваші роути

test('renders user profile with correct ID', () => {
  const { getByText } = render(
    <MemoryRouter initialEntries={['/user/123']}>
      <MyRoutes />
    </MemoryRouter>
  );
  const userProfileElement = getByText(/User Profile: 123/i);
  expect(userProfileElement).toBeInTheDocument();
});
```

```javascript
// Приклад роутів (MyRoutes.js)
import React from 'react';
import { Switch, Route } from 'react-router-dom';

const Home = () => <div>Welcome to our app</div>;
const About = () => <div>About us</div>;
const UserProfile = ({ match }) => (
  <div>User Profile: {match.params.id}</div>
);

const MyRoutes = () => (
  <Switch>
    <Route exact path="/" component={Home} />
    <Route path="/about" component={About} />
    <Route path="/user/:id" component={UserProfile} />
  </Switch>
);

export default MyRoutes;
```
```javascript
// Приклад роутів (MyRoutes.test.js)
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { createMemoryHistory } from 'history';
import { Router } from 'react-router-dom';
import MyRoutes from './My
```

## Кращі практики написання та організації тестів у React додатках

### Види тестів

Перш ніж перейти до імплементації, давайте розглянемо різні види тестів:

- **Модульні тести** перевіряють незалежний блок коду (клас, функцію) в ізоляції. Вони допомагають виявити помилки на ранніх етапах розробки.
- **Інтеграційні тести** перевіряють взаємодію декількох блоків (ієрархію компонентів, компонент + сховище даних).
- **Тести end-to-end (E2E)** перевіряють застосунок ззовні (наприклад, з браузера).

Разом вони утворюють ієрархію тестів, де тести на вищих рівнях дають більше впевненості у роботі системи та взаємодії компонентів між собою.

### Програми для запуску тестів

У нових проєктах на React найпростіше налаштувати тестування за допомогою Create React App. Під час генерації проєкту (команда `npx create-react-app myapp`) вам потрібно активувати тестування. Модульні/інтеграційні тести зберігатимуться у теці `src` з розширенням `.spec.js` або `.test.js`. Create React App використовує фреймворк для тестування Jest.

### Окремий блок коду

Давайте напишемо приклад модульного тесту:

```javascript
describe('toUpperCase', () => {
  it('should convert string to upper case', () => {
    // Підготовка
    const toUpperCase = info => info.toUpperCase();
    // Дія
    const result = toUpperCase('Click to modify');
    // Ствердження
    expect(result).toEqual('CLICK TO MODIFY');
  });
});
```

Цей тест перевіряє, щоб функція `toUpperCase` повертала правильний результат. В першому блоці (підготовка) ми отримуємо потрібну функцію у прийнятному для тестів вигляді. Далі ми виконуємо функцію/метод (дія) і стверджуємо, яким він повинен бути.
