---
outline: deep
---

# Робота з об'єктами та масивами у JavaScript

## Масиви
Об’єкти дозволяють зберігати набори значень з ключами. Це чудово.

Але досить часто ми розуміємо, що нам необхідна впорядкована колекція даних, яка складається з 1-го, 2-го, 3-го і т.д. елементів. Наприклад, така колеція може знадобитись для зберігання списку користувачів, товарів, HTML елементів та ін.

Використовувати об’єкти в такому випадку не зручно, тому що вони не надають методів управління порядком елементів. Ми не можемо вставити нову властивість “між” існуючих. Об’єкти просто не призначені для цього.

Для зберігання впорядкованих колекцій існує інший тип даних, який має назву масив, `Array`.

### Оголошення
Існує два типи синтаксису для створення порожнього масиву:
```js
let arr = new Array();
let arr = [];
```
Майже завжди використовують другий тип синтаксису. Ми можемо вказати початкові елементи масиву у квадратних дужках:
```js
let fruits = ["Apple", "Orange", "Plum"];
```
Елементи масиву нумеруються починаючи з нуля.

Ми можемо отримати елемент масиву, вказавши його номер в квадратних дужках:

```js
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
```

Можемо замінити елемент:
```js
fruits[2] = 'Pear'; // тепер ["Apple", "Orange", "Pear"]
```
Або додати новий:
```js
fruits[3] = 'Lemon'; // тепер ["Apple", "Orange", "Pear", "Lemon"]
```

Загальна кількість елементів масиву зберігається у його властивості length:

```js
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
```
Ми можемо переглянути масив цілком за допомогою alert
```js
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
```
У масивах можуть зберігатись елементи будь-якого типу.
```js
// різні типи значень
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// отримати елемент з індексом 1 (об’єкт) та вивести його властивість name
alert( arr[1].name ); // John

// отримати елемент з індексом 3 (функція) та виконати її
arr[3](); // hello
```
::: tip Кома в кінці
Список елементів масиву, як і список елементів об’єкту може закінчуватись комою:
```js
let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
```
Кома в кінці спрощує процес додавання/видалення елементів, тому що всі рядки стають однотипними.
:::

### Отримати останні елементи за допомогою “at”
Скажімо, нам потрібен останній елемент масиву.

Деякі мови програмування дозволяють використовувати негативні індекси з цією ж метою, наприклад, `fruits[-1]`.

Хоча в JavaScript це не працюватиме. Результат буде `undefined`, оскільки індекс у квадратних дужках трактується буквально.

Ми можемо явно обчислити індекс останнього елемента, а потім отримати до нього доступ: `fruits[fruits.length - 1]`.
```js
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[fruits.length-1] ); // Plum
```
Трохи громіздко, чи не так? Нам потрібно двічі написати ім’я змінної.
На щастя, є коротший синтаксис: fruits.at(-1):
```js
let fruits = ["Apple", "Orange", "Plum"];

// те ж саме що й fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
```

### Методи pop/push, shift/unshift
`Черга` — один з найбільш популярних варіантів використання об’єкту. У ком’ютерних науках так позначають колекцію елементів, яка підтримує дві операції:

* `push` додає елемент у кінець списку.
* `shift` видаляє елемент на початку, зміщчуючи чергу, таким чином, що 2-й елемент стає 1-м.

Масиви підтримують обидві операції.

На практиці це дуже часто стає у нагоді. Наприклад, черга з повідомлень, які необхідно показувати на екрані.

Існує також інший варіант використання масивів – структура даних, яка називається стек.

Вона підтримує два типи операцій:

* `push` додає елементи в кінець.
* `pop` видаляє елемент з кінця.
Таким чином нові елементи завжди додаються або видаляються з “кінця”.

Хорошим прикладом стеку є колода карт: нові карти кладуться на верх і беруться теж зверху.
У стеках – останній доданий елемент повертається першим, цей принцип також називають LIFO (з англ. Last-In-First-Out, “останій прийшов – перший пішов”). Для черг ми використовуємо принцип FIFO (з англ. First-In-First-Out, “перший прийшов – перший пішов”).

Масиви в JavaScript можуть працювати як стеки і як черги. Ми можемо додавати/видаляти елементи як на початку так і у кінці масиву.

В комп’ютерних науках структури даних, які дозволяють це робити, мають назву двобічна черга.
`pop`. Видаляє останній елемент масиву та повертає його:
```js
let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // видаляємо "Pear" та виводимо його

alert( fruits ); // Apple, Orange
```
І `fruits.pop()`, і `fruits.at(-1)` повертають останній елемент масиву, але `fruits.pop()` також змінює масив, видаляючи його.

`push`. Додає елемент в кінець масиву:
```js
let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
```
`shift`. Видаляє перший елемент з масиву та повертає його:
```js
let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // видаляємо Apple та виводимо його

alert( fruits ); // Orange, Pear
```
`unshift`. Додає елемент в початок масиву:
```js
let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
```
Методи push та unshift можуть додавати одразу декілька елементів:
```js
let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
```
### Внутрішня структура масивів

Масив – це спеціальний вид об’єктів. Квадратні дужки використовують для доступу до властивості `arr[0]`, що в свою чергу прийшло з синтаксису об’єктів. Це теж саме, що доступ до властивості об’єкта `obj[key]`, де arr це об’єкт в якому числа використовуються як ключі.

Масиви розширюють функціональність об’єкта тим, що надають можливість працювати з упорядкованими колекціями даних, а також надають доступ до властивості `length`. Але в основі це досі об’єкт.

Запам’ятайте, JavaScript містить лише 8 базових типів даних (більше інформації у розділі Типи даних). Масив – це об’єкт, який поводить себе як об’єкт.

Наприклад, копіюється за посиланням:
```js
let fruits = ["Banana"]

let arr = fruits; // копіюється за посиланням (дві змінні посилаються на один масив)

alert( arr === fruits ); // true

arr.push("Pear"); // зміна масиву за посиланням

alert( fruits ); // Banana, Pear - наразі два елемента
```
…Але те, що робить масиви дійсно особливими – це їх внутрішнє представлення. Рушій JavaScript намагається зберігати елементи масиву у неперервній області пам’яті, один за одним, як це представлено на ілюстраціях в цьому розділі, а також застосовує інші способи оптимізації, що дозволяють масивам працювати дуже швидко.

Проте масиви втратять всю свою ефективність, якщо ми перестанемо працювати з ними як з “упорядкованою колекцією даних” і почнемо використовувати як звичайний об’єкт.

Наприклад, технічно ми можемо виконати наступне:

```js
let fruits = []; // створюємо масив

fruits[99999] = 5; // створюємо властивість, індекс якої набагато перевищує довжину масиву

fruits.age = 25; // створюємо властивість з довільним ім’ям

```

Це можливо тому, що в основі масивів — об’єкти. Ми можемо додати будь-які властивості до них.

Але рушій зрозуміє, що ми використувуємо масиви, як звичайні об’єкти. Методи оптимізації, які використовуються для масивів в цьому випадку не підходять, тому будуть відключені і не принесуть ніякої користі.

Варіанти неправильного використання масивів:

* Додавання нечислових властивостей, таких як `arr.test = 5`.
* Створення “дірок”, наприклад: `arr[0]` а за ним `arr[1000]` (та нічого між цими елементами).
* Заповнення масиву в зворотньому порядку, наприклад: `arr[1000]`, `arr[999]` і т. д.

Будь ласка, думайте про масиви як про особливі структури для роботи з впорядкованими даними. Вони надають спеціальні методи для цього. Масиви дуже ретельно налаштовані на роботу з неперервними впорядкованими даними, тому використовуйте їх саме таким чином. Тому, якщо вам необхідні довільні ключі, дуже ймовірно, що вам більше підійдуть звичайні об’єкти {}.

### new Array()
Існує ще один варіант створення масиву:
```js
let arr = new Array("Apple", "Pear", "etc");
```
Він використовується рідше, адже квадратні дужки коротші []. А також має певну особливість.

Якщо new Array викликається з одним аргументом, а саме числом, він створить порожній масив з довжиною, яка дорівнює цьому числу.

Подивімось, як можна завдати собі ведмежої послуги:
```js
let arr = new Array(2); // чи створиться масив [2] ?

alert( arr[0] ); // undefined! елементи відсутні.

alert( arr.length ); // довжина 2
```
Для того, щоб позбутись таких сюрпризів, як правило, ми використовуємо квадратні дужки [], якщо тільки ми дійсно не маємо причини для використання методу new Array.

## Практичний приклад 

<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/steminist-ua/embed/wvbpKVR?default-tab=&editable=true&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/steminist-ua/pen/wvbpKVR">
  Untitled</a> by Anastasiia Steminist (<a href="https://codepen.io/steminist-ua">@steminist-ua</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

## Багатовимірні масиви

Масиви можуть містити елементи, які своєю чергою теж є масивами. Ми можемо використовувати це для створення багатовимірних масивів, наприклад, для зберігання матриць:

```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, центральний елемент
```

## toString

Масиви по-своєму реалізують метод toString, який повертає список елементів розділених комою.

Наприклад:
```js
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
Спробуймо це:
```js
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```
Масиви не мають `Symbol.toPrimitive`, або функціонуючого `valueOf`, вони реалізують лише метод `toString` таким чином, що `[]` стає порожнім рядком, `[1]` стає "1" або `[1,2]` стає "1,2".

Коли бінарний оператор "+" додає щось до рядка, це конвертується в рядок та виглядає наступним чином:
```js 
alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
```

## Не порівнюйте масиви за допомогою ==

На відміну від інших мов програмування, масиви в JavaScript не варто порівнювати за допомогою оператора `==.`

Цей оператор не має спеціальних методів для опрацювання масивів, тому він працює з ними, як з об’єктами.

Давайте згадаємо правила:

* Два об’єкти рівні `==` лише коли вони посилаються на один об’єкт.
* Якщо один з аргументів оператора `==` об’єкт, а інший — примітив, тоді об’єкт конвертується в примітив. Це пояснюється в розділі Перетворення об’єктів в примітиви.
* …Лише два виключення — це `null` та `undefined`, які рівні `==` один одному та нічому більше.
Строге порівняння `===` ще простіше, тому що не конвертує типи.

Тому, якщо ми порівнюємо масиви оператором `==`, то вони ніколи не будуть однаковими, за виключенням, коли ми порівнюємо дві змінні, які посилаються на один масив.

```js 
alert( [] == [] ); // false
alert( [0] == [0] ); // false
```


## Практичний приклад 

<iframe height="300" style="width: 100%;" scrolling="no" title="WebDev3" src="https://codepen.io/steminist-ua/embed/Rwmxrby?default-tab=&editable=true&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/steminist-ua/pen/Rwmxrby">
  WebDev3</a> by Anastasiia Steminist (<a href="https://codepen.io/steminist-ua">@steminist-ua</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

## Ітеративні об’єкти

Ітеративні об’єкти є узагальненням масивів. Це концепція, яка дозволяє нам зробити будь-який об’єкт придатним для використання в циклі `for..of`.

Звичайно, по масивах можна ітеруватися. Але є багато інших вбудованих об’єктів, які також можна ітерувати. Наприклад, рядки також можна ітерувати.

Якщо об’єкт технічно не є масивом, а представляє колекцію (list, set) чогось, то `for..of` – чудовий синтаксис для його обходу, тому подивімось, як змусити його працювати.

### Symbol.iterator

Ми можемо легко зрозуміти концепцію ітеративних об’єктів, зробивши її власноруч.

Наприклад, у нас є об’єкт, який не є масивом, але виглядає придатним для `for..of`.

Як, наприклад, об’єкт range, який представляє інтервал чисел:
```js
let range = {
  from: 1,
  to: 5
};

// Ми хочемо, щоб for..of працював:
// for(let num of range) ... num=1,2,3,4,5
```

Щоб зробити об’єкт range ітерабельним (і таким чином дозволити `for..of` працювати), нам потрібно додати метод до об’єкта з назвою `Symbol.iterator` (спеціальний вбудований символ саме для цього).

1. Коли `for..of` запускається, він викликає цей метод один раз (або викидає помилку, якщо цей метод не знайдено). Метод повинен повернути `iterator` – об’єкт з методом next.
2. Далі `for..of` працює лише з поверненим об’єктом.
3. Коли `for..of` хоче отримати наступне значення, він викликає next() на цьому об’єкті.
4. Результат next() повинен мати вигляд {done: Boolean, value: any}, де done=true означає, що ітерація завершена, інакше value – це наступне значення.

Ось повна реалізація об’єкту range із зауваженнями:
```js
let range = {
  from: 1,
  to: 5
};

// 1. виклик for..of спочатку викликає цю функцію
range[Symbol.iterator] = function() {

  // 2. Далі, for..of працює тільки з цим ітератором, запитуючи у нього наступні значення
  return {
   current: this.from,
   last: this.to,

    next() {
      // 4. він повинен повертати значення як об’єкт {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// тепер це працює!
for (let num of range) {
  alert(num); // 1, потім 2, 3, 4, 5
}
```

Будь ласка, зверніть увагу на основну особливість ітеративних об’єктів: розділення проблем.

Сам range не має методу `next()`.
Натомість інший об’єкт, так званий “ітератор”, створюється за допомогою виклику `range[Symbol.iterator]()`, а його next() генерує значення для ітерації.
Отже, об’єкт, що ітерує відокремлений від об’єкта, який він ітерує.

Технічно, ми можемо об’єднати їх і використовувати range в якості ітератора, щоб зробити код простішим.

### Виклик ітератора явно

Ми будемо ітерувати рядок точно так само, як для for..of, але з прямими викликами. Цей код створює ітератор рядка і отримує значення від нього “вручну”:
```js
let str = "Привіт";

// робить те ж саме, як
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // виводить символи один за одним
}
```
Це рідко потрібно, але дає нам більше контролю над процесом, ніж `for ..of`. Наприклад, ми можемо розділити процес ітерації: трохи ітерувати, а потім зупинитися, зробити щось інше, а потім відновити пізніше.

### Array.from
Існує універсальний метод Array.from, який приймає ітерований об’єкт або псевдомасив і робить з нього “справжній” масив. Тоді ми можемо викликати на ньому методи масиву.

```js
let arrayLike = {
  0: "Привіт",
  1: "Світ",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // Світ (метод працює)
```
Array.from у рядку (*) бере об’єкт, перевіряє його на ітерабельність або те, що це псевдомасив, потім створює новий масив і копіює до нього всі елементи.

Те ж саме відбувається і з ітерованим об’єктом:

```js
// припустимо, що діапазон взятий з наведеного вище прикладу
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (array toString conversion works)
```
## Об’єкти

В JavaScript об'єкти є основною будівельною одиницею програмування і використовуються для зберігання і обробки даних. Об'єкти можуть містити як властивості (properties), так і методи (methods), що дозволяє створювати складні структури даних і функціональність.

### Створення об’єктів

В JavaScript об'єкти можна створювати кількома способами:

#### Літеральна нотація

```javascript
// Створення об'єкта з використанням літеральної нотації
const person = {
    firstName: 'John',
    lastName: 'Doe',
    age: 30,
    greet: function() {
        return `Hello, my name is ${this.firstName} ${this.lastName}.`;
    }
};

console.log(person.firstName); // Виведе: John
console.log(person.greet()); // Виведе: Hello, my name is John Doe.
```

#### Використання конструктора об’єкта

```javascript
// Використання конструктора об'єкта
function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.displayInfo = function() {
        return `Car: ${this.year} ${this.make} ${this.model}`;
    };
}

const myCar = new Car('Toyota', 'Camry', 2022);
console.log(myCar.displayInfo()); // Виведе: Car: 2022 Toyota Camry
```

### Властивості і методи об’єктів

У JavaScript об'єкти можуть мати різні типи властивостей:

- **Динамічні властивості**: Властивості, які можна додати або видалити в будь-який час.

```javascript
const person = {};
person.firstName = 'John';
person.lastName = 'Doe';
```

- **Методи**: Функції, що є властивостями об'єкта і використовуються для виконання певних дій.

```javascript
const person = {
    firstName: 'John',
    lastName: 'Doe',
    fullName: function() {
        return `${this.firstName} ${this.lastName}`;
    }
};
console.log(person.fullName()); // Виведе: John Doe
```

### Доступ до властивостей об’єктів

Для отримання доступу до властивостей об'єктів використовуються крапки або квадратні дужки:

```javascript
const person = {
    firstName: 'John',
    lastName: 'Doe'
};

console.log(person.firstName); // Виведе: John
console.log(person['lastName']); // Виведе: Doe
```

### Об’єкти і прототипи

JavaScript є прототипно-орієнтованою мовою, що означає, що всі об'єкти успадковують методи і властивості від свого прототипу. Це дозволяє створювати і використовувати об'єкти з різними поведінками і функціональністю.

```javascript
// Використання прототипу для створення об'єкта
const personProto = {
    greet: function() {
        return `Hello, my name is ${this.firstName} ${this.lastName}.`;
    }
};

const person1 = Object.create(personProto);
person1.firstName = 'John';
person1.lastName = 'Doe';

console.log(person1.greet()); // Виведе: Hello, my name is John Doe.
```

Ці приклади демонструють основні аспекти створення і використання об'єктів в JavaScript, що дозволяють створювати і керувати складними структурами даних та функціональністю програм.

### Властивість зі змінної
В JavaScript можна створювати властивості об'єктів з використанням змінних. Це дозволяє динамічно визначати назву властивості під час виконання програми. Ось приклади:

### Створення властивостей об'єкту зі змінної

```javascript
// Змінна для назви властивості
const propertyName = 'firstName';

// Створення об'єкта та додавання властивості через змінну
const person = {};
person[propertyName] = 'John';

console.log(person.firstName); // Виведе: John
```

У цьому прикладі `propertyName` є змінною, яка містить рядок `'firstName'`. Ми використовуємо цю змінну як ім'я властивості об'єкту `person`. Після виконання цього коду в об'єкті `person` з'являється властивість `firstName` зі значенням `'John'`.

Цей підхід дозволяє програмістам створювати та маніпулювати об'єктами динамічним чином, що є корисним при обробці даних змінної природи або при роботі з динамічно згенерованими структурами даних.

### Обмеження для імен властивостей
В JavaScript імена властивостей об'єктів повинні відповідати певним обмеженням і правилам. Ось основні обмеження для імен властивостей об'єктів:

1. **Синтаксичні обмеження:**
   - Ім'я властивості може містити літери (a-z, A-Z), цифри (0-9), символи `_` (підкреслення) та `$` (долар).
   - Першим символом імені повинна бути літера, `_` або `$`.
   - Ім'я властивості не може починатися з цифри.

2. **Ключові слова і обмеження використання:**
   - Не можна використовувати зарезервовані слова як імена властивостей. Наприклад, `class`, `for`, `if`, `return`, тощо.
   - Імена властивостей чутливі до регістру символів. `firstName` і `FirstName` розглядаються як різні властивості.

3. **Динамічне визначення імен властивостей:**
   - Імена властивостей можуть бути визначені динамічно з використанням змінних або результатів виразів. Наприклад:
     ```javascript
     const prefix = 'user';
     const suffix = 'Name';
     const propertyName = prefix + suffix;
     const obj = {};
     obj[propertyName] = 'John';
     console.log(obj.userName); // Виведе: John
     ```

Загалом, імена властивостей об'єктів в JavaScript мають бути валідними ідентифікаторами згідно зі специфікацією мови. Дотримання цих правил дозволяє ефективно створювати та управляти об'єктами, що є важливим аспектом програмування на JavaScript.

### Перевірка існування властивості, оператор “in”
У JavaScript оператор `in` використовується для перевірки існування властивостей в об'єктах. Він повертає `true`, якщо властивість існує у зазначеному об'єкті або у його прототипах, і `false`, якщо властивість відсутня. Ось декілька прикладів використання оператора `in`:

### Перевірка існування властивості в об'єкті

```javascript
const person = {
    firstName: 'John',
    lastName: 'Doe',
    age: 30
};

console.log('firstName' in person); // Виведе: true
console.log('country' in person);   // Виведе: false
```

У цьому прикладі оператор `in` перевіряє наявність властивостей `'firstName'` і `'country'` в об'єкті `person`. Оскільки `'firstName'` є властивістю об'єкту `person`, результат першого `console.log` буде `true`. `'country'` не є властивістю `person`, тому результат другого `console.log` буде `false`.

### Перевірка наявності властивостей у прототипах об'єктів

```javascript
function Person(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
}

Person.prototype.age = 30;

const john = new Person('John', 'Doe');

console.log('firstName' in john); // Виведе: true
console.log('age' in john);       // Виведе: true
console.log('country' in john);   // Виведе: false
```

У цьому прикладі `Person` є конструктором, який створює об'єкти з властивостями `firstName` і `lastName`. Проте, у прототипі `Person.prototype` є додаткова властивість `age`. Оператор `in` перевіряє наявність цих властивостей в об'єкті `john`. Властивості `firstName` і `age` існують у `john`, тому перші два `console.log` повернуть `true`. Властивість `country` не є властивістю ні в об'єкті `john`, ні в його прототипах, тому останній `console.log` поверне `false`.

### Використання оператора `in` з масивами

В JavaScript також можна використовувати оператор `in` для перевірки існування індексів у масивах:

```javascript
const colors = ['red', 'green', 'blue'];

console.log(0 in colors);   // Виведе: true
console.log(3 in colors);   // Виведе: false (елемент з індексом 3 не існує)
console.log('length' in colors); // Виведе: true (length - властивість масиву)
```

У цьому прикладі `0` і `3` є індексами масиву `colors`. Індекс `0` існує, тому перший `console.log` поверне `true`, а індекс `3` не існує, тому другий `console.log` поверне `false`. Властивість `length` існує в масиві `colors`, тому третій `console.log` поверне `true`.

Оператор `in` є корисним інструментом для динамічної перевірки наявності властивостей та індексів у JavaScript.

### Копіювання об’єктів та посилання

У JavaScript робота з копіюванням об'єктів може бути не такою простою, як здається на перший погляд через особливості посилань. Ось основні аспекти, які слід враховувати:

#### 1. Поверхневе копіювання

При поверхневому копіюванні створюється новий об'єкт, але внутрішні об'єкти (якщо вони є) залишаються тими ж самими.

```javascript
const original = { key: 'value' };
const copy = Object.assign({}, original);

console.log(copy); // { key: 'value' }
console.log(original === copy); // false
```

#### 2. Глибоке копіювання

Глибоке копіювання створює копію об'єкта разом із всіма вкладеними об'єктами та масивами.

```javascript
const original = { nestedObj: { key: 'value' } };
const deepCopy = JSON.parse(JSON.stringify(original));

console.log(deepCopy); // { nestedObj: { key: 'value' } }
console.log(original === deepCopy); // false
```

Проте, зауважте, що при глибокому копіюванні втрачаються специфічні типи даних, такі як функції або регулярні вирази, і це може вплинути на поведінку вашого коду.

#### 3. Посилання

У JavaScript об'єкти передаються за посиланням, тому в деяких випадках зміна одного об'єкта може вплинути на інший, якщо вони посилаються на один і той самий об'єкт в пам'яті.

```javascript
const original = { key: 'value' };
const reference = original;

reference.key = 'new value';

console.log(original.key); // 'new value'
```

В цьому прикладі `reference` і `original` посилаються на один і той самий об'єкт в пам'яті, тому зміни в одному об'єкті відображаються в іншому.

#### Висновок

Розуміння того, як працює копіювання та посилання в JavaScript, допомагає уникнути побічних ефектів та непередбачених змін в вашому коді. Використання відповідних методів копіювання, таких як `Object.assign` для поверхневого копіювання або `JSON.parse(JSON.stringify(obj))` для глибокого копіювання, є важливими аспектами розробки програмного забезпечення на JavaScript.

### Методи об’єкта та ключове слово "this"

В JavaScript методи об'єктів є функціями, які визначаються як властивості об'єкта. Вони дозволяють об'єктам виконувати операції та маніпулювати їхніми властивостями. Ключове слово `this` в методах об'єкта вказує на сам об'єкт, через який викликається метод.

#### Створення методу об'єкта

```javascript
const person = {
    firstName: 'John',
    lastName: 'Doe',
    fullName: function() {
        return this.firstName + ' ' + this.lastName;
    }
};

console.log(person.fullName()); // Виведе: John Doe
```

У цьому прикладі `fullName` є методом об'єкта `person`, який повертає повне ім'я, складене з властивостей `firstName` і `lastName`. Ключове слово `this` вказує на поточний об'єкт `person`, через який викликається метод `fullName`.

#### Використання "this" в контексті об'єкта

```javascript
const user = {
    name: 'Alice',
    greet: function() {
        return `Hello, ${this.name}!`;
    }
};

console.log(user.greet()); // Виведе: Hello, Alice!
```

У цьому прикладі `this.name` використовується для отримання значення властивості `name` поточного об'єкту `user`. Ключове слово `this` забезпечує доступ до властивостей об'єкта, до якого метод належить.

#### Виклик методу через інший об'єкт

```javascript
const person1 = {
    name: 'Bob',
    greet: function() {
        return `Hello, ${this.name}!`;
    }
};

const person2 = {
    name: 'Emily'
};

person2.greet = person1.greet;

console.log(person2.greet()); // Виведе: Hello, Emily!
```

У цьому прикладі метод `greet` об'єкта `person1` присвоюється властивості `greet` об'єкта `person2`. При виклику `person2.greet()`, `this` вказує на `person2`, тому `this.name` виводить значення `name` об'єкта `person2`, а саме `'Emily'`.

#### Висновок

Використання ключового слова `this` в методах об'єктів дозволяє звертатися до поточного об'єкта, через який викликається метод. Це дає можливість звертатися до властивостей і методів об'єкта з внутрішньої частини методу, що робить код більш динамічним та зручним для роботи з об'єктами в JavaScript.

### Map і Set в JavaScript

#### Map

Map є структурою даних у JavaScript, яка дозволяє зберігати колекцію ключ-значення, де кожен ключ і його значення може бути будь-якого типу. Ось основні особливості Map:

- **Додавання елементів:**
  ```javascript
  const map = new Map();
  map.set('key1', 'value1');
  map.set('key2', 'value2');
  ```

- **Отримання значень за ключем:**
  ```javascript
  console.log(map.get('key1')); // Виведе: value1
  ```

- **Перевірка наявності ключа:**
  ```javascript
  console.log(map.has('key2')); // Виведе: true
  ```

- **Видалення елемента за ключем:**
  ```javascript
  map.delete('key1');
  ```

- **Розмір Map:**
  ```javascript
  console.log(map.size); // Виведе: 1 (після видалення 'key1')
  ```

- **Ітерація через ключі та значення:**
  ```javascript
  map.forEach((value, key) => {
      console.log(`${key}: ${value}`);
  });
  ```

#### Set

Set є колекцією унікальних значень у JavaScript, тобто вона не дозволяє дублювання елементів. Ось основні особливості Set:

- **Додавання елементів:**
  ```javascript
  const set = new Set();
  set.add('value1');
  set.add('value2');
  ```

- **Перевірка наявності значення:**
  ```javascript
  console.log(set.has('value2')); // Виведе: true
  ```

- **Видалення елемента:**
  ```javascript
  set.delete('value1');
  ```

- **Розмір Set:**
  ```javascript
  console.log(set.size); // Виведе: 1 (після видалення 'value1')
  ```

- **Ітерація через значення:**
  ```javascript
  set.forEach(value => {
      console.log(value);
  });
  ```

#### Використання Map і Set

Map і Set дуже корисні для зберігання даних без дублювання та для швидкого доступу до елементів за ключами чи значеннями. Вони забезпечують ефективні алгоритми для додавання, видалення та пошуку елементів, що робить їх чудовими варіантами для багатьох сценаріїв програмування у JavaScript.

## WeakMap та WeakSet
### WeakMap і WeakSet в JavaScript

#### WeakMap

WeakMap є спеціальним типом Map у JavaScript, який дозволяє використовувати тільки об'єкти як ключі і зберігає їх у вигляді посилань, тобто не утримує на них посилань в пам'яті, якщо інші частини програми не використовують ці об'єкти. Ось основні особливості WeakMap:

- **Додавання елементів:**
  ```javascript
  let obj1 = {};
  let obj2 = {};

  const weakMap = new WeakMap();
  weakMap.set(obj1, 'value1');
  weakMap.set(obj2, 'value2');
  ```

- **Отримання значень за ключем:**
  ```javascript
  console.log(weakMap.get(obj1)); // Виведе: value1
  ```

- **Перевірка наявності ключа:**
  ```javascript
  console.log(weakMap.has(obj2)); // Виведе: true
  ```

- **Видалення елемента за ключем:**
  ```javascript
  weakMap.delete(obj1);
  ```

#### Відмінності від Map:

- **Автоматичне видалення ключів:**
  Якщо об'єкт-ключ у WeakMap видаляється з пам'яті, наприклад, коли він більше не використовується в іншій частині програми, він автоматично видаляється з WeakMap. Це дозволяє уникнути утримання непотрібних ресурсів в пам'яті.

#### WeakSet

WeakSet є спеціальним типом Set, який також може містити тільки об'єкти і зберігає їх у вигляді посилань. Ось основні особливості WeakSet:

- **Додавання елементів:**
  ```javascript
  let obj1 = {};
  let obj2 = {};

  const weakSet = new WeakSet();
  weakSet.add(obj1);
  weakSet.add(obj2);
  ```

- **Перевірка наявності значення:**
  ```javascript
  console.log(weakSet.has(obj2)); // Виведе: true
  ```

- **Видалення елемента:**
  ```javascript
  weakSet.delete(obj1);
  ```

#### Відмінності від Set:

- **Автоматичне видалення елементів:**
  Як і WeakMap, WeakSet автоматично видаляє елементи, коли вони більше не потрібні в пам'яті. Це робить його корисним для зберігання тимчасових даних, які не потрібно утримувати в пам'яті програми.

#### Використання WeakMap і WeakSet

WeakMap і WeakSet корисні в ситуаціях, коли ви хочете зберігати дані, але не хочете утримувати об'єкти в пам'яті, якщо немає жодних інших посилань на них. Вони часто використовуються для реалізації кешування, відслідковування слабких посилань або в інших архітектурних паттернах, де автоматичне управління пам'яттю є важливим аспектом.

### Object.keys, Object.values, Object.entries

#### Object.keys

Метод `Object.keys` в JavaScript повертає масив строкових значень, які представляють усі власні перечислювані властивості об'єкта.

```javascript
const obj = {
    name: 'John',
    age: 30,
    city: 'New York'
};

const keys = Object.keys(obj);
console.log(keys); // Виведе: ["name", "age", "city"]
```

У цьому прикладі `Object.keys` повертає масив ключів (`["name", "age", "city"]`) об'єкта `obj`.

#### Object.values

Метод `Object.values` повертає масив значень властивостей об'єкта в тому порядку, у якому вони були перечислені в об'єкті.

```javascript
const obj = {
    name: 'John',
    age: 30,
    city: 'New York'
};

const values = Object.values(obj);
console.log(values); // Виведе: ["John", 30, "New York"]
```

У цьому прикладі `Object.values` повертає масив значень (`["John", 30, "New York"]`) властивостей об'єкта `obj`.

#### Object.entries

Метод `Object.entries` повертає масив масивів, кожен з яких представляє пару ключ-значення для кожної властивості об'єкта в тому порядку, у якому вони були перечислені.

```javascript
const obj = {
    name: 'John',
    age: 30,
    city: 'New York'
};

const entries = Object.entries(obj);
console.log(entries);
// Виведе: [["name", "John"], ["age", 30], ["city", "New York"]]
```

У цьому прикладі `Object.entries` повертає масив масивів (`[["name", "John"], ["age", 30], ["city", "New York"]]`), представляючи кожну пару ключ-значення об'єкта `obj`.

#### Використання методів Object.keys, Object.values, Object.entries

Ці методи корисні для роботи з об'єктами в JavaScript, дозволяючи отримувати доступ до їхніх властивостей, ключів і значень. Вони є зручними для ітерації або обробки даних у циклах, а також для перетворення об'єктів на масиви для подальшої обробки або виведення.

### Деструктуроване присвоєння в JavaScript

Деструктуроване присвоєння - це зручний спосіб отримати значення з об'єкту або масиву і присвоїти їх змінним у JavaScript.

#### Деструктурування об'єктів

##### Простий приклад:

```javascript
const person = { name: 'John', age: 30 };

const { name, age } = person;

console.log(name); // Виведе: John
console.log(age);  // Виведе: 30
```

У цьому прикладі `{ name, age } = person;` означає, що ми деструктуруємо об'єкт `person` і витягуємо значення `name` і `age`, які призначаємо змінним з відповідними іменами.

##### Перейменування змінних:

```javascript
const person = { name: 'John', age: 30 };

const { name: fullName, age: yearsOld } = person;

console.log(fullName); // Виведе: John
console.log(yearsOld); // Виведе: 30
```

У цьому прикладі ми деструктуруємо `name` і `age` з `person`, але призначаємо їх змінним `fullName` і `yearsOld`.

#### Деструктурування масивів

##### Простий приклад:

```javascript
const numbers = [1, 2, 3, 4, 5];

const [first, second, third] = numbers;

console.log(first);  // Виведе: 1
console.log(second); // Виведе: 2
console.log(third);  // Виведе: 3
```

У цьому прикладі `[first, second, third] = numbers;` означає, що ми деструктуруємо масив `numbers` і присвоюємо перші три елементи змінним `first`, `second` і `third`.

##### Пропуск елементів:

```javascript
const numbers = [1, 2, 3, 4, 5];

const [first, , third] = numbers;

console.log(first);  // Виведе: 1
console.log(third);  // Виведе: 3
```

У цьому прикладі ми пропускаємо другий елемент масиву, використовуючи кому між іменами змінних в деструктуруванні.

#### Використання деструктурованого присвоєння

Деструктуроване присвоєння є потужним інструментом для швидкого отримання доступу до властивостей об'єктів або елементів масивів у JavaScript. Воно спрощує код і дозволяє елегантно працювати з структурами даних.

### Методи toJSON і методи JSON в JavaScript

#### Метод `toJSON`

Метод `toJSON` є спеціальним методом у JavaScript, який використовується для перетворення об'єкта на JSON-представлення. Цей метод може бути викликаний автоматично під час серіалізації об'єкта у JSON за допомогою методу `JSON.stringify`.

```javascript
const obj = {
    firstName: 'John',
    lastName: 'Doe',
    age: 30,
    toJSON: function() {
        return {
            fullName: `${this.firstName} ${this.lastName}`,
            age: this.age
        };
    }
};

console.log(JSON.stringify(obj));
// Виведе: {"fullName":"John Doe","age":30}
```

У цьому прикладі метод `toJSON` визначений у об'єкті `obj`, і він повертає об'єкт з властивостями `fullName` і `age`. Коли викликається `JSON.stringify(obj)`, метод `toJSON` автоматично викликається для перетворення об'єкта `obj` на JSON-строку з властивостями, які відповідають тому, що повертає `toJSON`.

#### Методи `JSON`

Методи `JSON` в JavaScript використовуються для роботи з JSON, включаючи серіалізацію і десеріалізацію даних.

##### `JSON.stringify`

Метод `JSON.stringify` використовується для перетворення об'єкта або значення в JSON-строку.

```javascript
const obj = { name: 'John', age: 30 };
const jsonString = JSON.stringify(obj);

console.log(jsonString); // Виведе: {"name":"John","age":30}
```

##### `JSON.parse`

Метод `JSON.parse` використовується для розбору JSON-строки і отримання об'єкта або значення, яке вона представляє.

```javascript
const jsonString = '{"name":"John","age":30}';
const obj = JSON.parse(jsonString);

console.log(obj.name); // Виведе: John
console.log(obj.age);  // Виведе: 30
```

#### Використання `toJSON` і методів `JSON`

Метод `toJSON` дозволяє керувати тим, як об'єкт перетворюється в JSON-строку, надаючи можливість змінювати структуру або включати лише певні властивості у вихідний JSON. Методи `JSON.stringify` і `JSON.parse` використовуються для роботи з JSON-даними і дозволяють ефективно перетворювати дані між об'єктами JavaScript і JSON-строками.

### Залишкові параметри (Rest Parameters) і Синтаксис поширення (Spread Syntax) в JavaScript

#### Залишкові параметри (Rest Parameters)

Залишкові параметри (Rest Parameters) - це механізм у JavaScript, що дозволяє передавати змінну кількість аргументів у функцію у вигляді масиву.

```javascript
function sum(...numbers) {
    let total = 0;
    for (let number of numbers) {
        total += number;
    }
    return total;
}

console.log(sum(1, 2, 3)); // Виведе: 6
console.log(sum(4, 5));    // Виведе: 9
console.log(sum(10));      // Виведе: 10
console.log(sum());        // Виведе: 0
```

У цьому прикладі `...numbers` є залишковим параметром, який збирає всі передані аргументи в масив `numbers`. Функція `sum` потім обчислює суму всіх чисел, переданих у викликах функції.

#### Синтаксис поширення (Spread Syntax)

Синтаксис поширення (Spread Syntax) в JavaScript використовується для розширення ітерабельних об'єктів (наприклад, масивів) у місцях, де очікується нуль або більше аргументів (для функцій) або елементів (для масивів).

##### Розгортання масивів:

```javascript
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const combinedArray = [...array1, ...array2];

console.log(combinedArray); // Виведе: [1, 2, 3, 4, 5, 6]
```

У цьому прикладі `[...array1, ...array2]` використовується для створення нового масиву `combinedArray`, який містить всі елементи з `array1` і `array2`.

##### Розгортання об'єктів:

```javascript
const obj1 = { name: 'John', age: 30 };
const obj2 = { city: 'New York' };

const mergedObj = { ...obj1, ...obj2 };

console.log(mergedObj);
// Виведе: { name: 'John', age: 30, city: 'New York' }
```

У цьому прикладі `{ ...obj1, ...obj2 }` використовується для створення нового об'єкта `mergedObj`, який містить всі властивості з `obj1` і `obj2`.

#### Використання залишкових параметрів і синтаксису поширення

Залишкові параметри і синтаксис поширення є потужними інструментами у JavaScript для роботи з функціями і структурами даних. Вони дозволяють зручно обробляти ітерабельні об'єкти, такі як масиви і об'єкти, і спрощують роботу з динамічною кількістю аргументів у функціях.

### Глобальний об’єкт в JavaScript

Глобальний об’єкт в JavaScript — це об’єкт, який представляє глобальний контекст в середовищі виконання JavaScript. У браузерах глобальний об’єкт називається `window`, а в Node.js — `global`. Він містить багато вбудованих властивостей і методів, які доступні у всій програмі без необхідності їх явного імпорту або включення.

#### Приклади властивостей і методів глобального об’єкта:

1. **console**: Об’єкт `console` надає методи для виведення даних у консоль, такі як `console.log`, `console.warn`, `console.error` і т.д.

   ```javascript
   console.log('Hello, world!');
   ```

2. **setTimeout, setInterval**: Глобальні функції `setTimeout` і `setInterval` використовуються для виконання коду через певний проміжок часу.

   ```javascript
   setTimeout(() => {
       console.log('Timeout executed!');
   }, 1000);
   ```

3. **Math**: Об’єкт `Math` містить математичні константи і функції для виконання математичних операцій.

   ```javascript
   console.log(Math.PI); // Виведе: 3.141592653589793
   ```

4. **Date**: Об’єкт `Date` використовується для роботи з датою і часом.

   ```javascript
   const currentDate = new Date();
   console.log(currentDate.getFullYear());
   ```

5. **Promise**: Клас `Promise` є глобальним і використовується для асинхронного програмування.

   ```javascript
   const promise = new Promise((resolve, reject) => {
       // Асинхронний код
       resolve('Success!');
   });
   ```

6. **globalThis**: В сучасних версіях JavaScript доступний об’єкт `globalThis`, який представляє глобальний об’єкт незалежно від середовища виконання (браузер або Node.js).

   ```javascript
   console.log(globalThis.innerWidth); // Властивість innerWidth браузера
   ```

#### Використання глобального об’єкта

Глобальний об’єкт використовується для доступу до різноманітних вбудованих можливостей JavaScript і надає зручний спосіб взаємодії з середовищем виконання програми. Однак варто звертати увагу на його використання і уникати зайвого забруднення глобального простору імен.

<iframe height="300" style="width: 100%;" scrolling="no" title="Untitled" src="https://codepen.io/steminist-ua/embed/QWRajoP?default-tab=&editable=true&theme-id=dark" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/steminist-ua/pen/QWRajoP">
  Untitled</a> by Anastasiia Steminist (<a href="https://codepen.io/steminist-ua">@steminist-ua</a>)
  on <a href="https://codepen.io">CodePen</a>.
</iframe>

## Тестування

<iframe width="100%" height="800px" src="https://forms.office.com/Pages/ResponsePage.aspx?id=L-F3avhuTkS5GDLm8-lbjrjWmio0yD5Cp1OXIfpVjlpUOEUyQVdITDEwQ0o1REhMTkhZTlVYVVJQNS4u&embed=true" frameborder="0" marginwidth="0" marginheight="0" style="border: none; max-width:100%; max-height:100vh" allowfullscreen webkitallowfullscreen mozallowfullscreen msallowfullscreen> </iframe>