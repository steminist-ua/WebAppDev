---
outline: deep
---

# Розробка інтерактивних веб-сторінок з використанням JavaScript

## DOM дерево
DOM (Document Object Model) — це структура, яка представляє HTML документ у вигляді дерева об'єктів. Кожен елемент HTML, його властивості і текст, а також взаємозв'язки між ними, представлені у вигляді об'єктів у цій моделі. JavaScript може взаємодіяти з DOM, змінюючи структуру, стилі і вміст сторінки в реальному часі.

### Основні поняття DOM

DOM включає такі основні поняття:

- **Елементи (Nodes)**: Основні будівельні блоки, такі як теги `<div>`, `<p>`, `<ul>`, `<li>`, які представляють структурні частини документа.
- **Атрибути**: Додаткова інформація про елементи, така як `id`, `class`, `src`, `href` і т.д.
- **Текстові вузли**: Вміст, який з'являється в межах елементів, наприклад, текст між тегами.
- **Родинні зв'язки**: Взаємозв'язки між елементами, такі як батьківські, дочірні і сусідні елементи.
- **Властивості**: Властивості, які визначають стиль, розмір, видимість та інші аспекти елементів на сторінці.

### Приклади коду

#### Отримання елемента за ідентифікатором:

```javascript
// HTML: <div id="myDiv">Це мій div</div>
const elementById = document.getElementById('myDiv');
console.log(elementById.textContent); // Виведе: Це мій div
```

#### Зміна текстового вмісту елемента:

```javascript
// HTML: <p id="myParagraph">Початковий текст</p>
const paragraph = document.getElementById('myParagraph');
paragraph.textContent = 'Новий текст для параграфа';
```

#### Додавання нового елемента до DOM:

```javascript
// HTML: <ul id="myList"></ul>
const list = document.getElementById('myList');
const newItem = document.createElement('li');
newItem.textContent = 'Новий елемент списку';
list.appendChild(newItem);
```

#### Зміна стилів елемента:

```javascript
// HTML: <div id="myDiv" style="background-color: yellow;">Це мій div</div>
const element = document.getElementById('myDiv');
element.style.backgroundColor = 'green';
element.style.color = 'white';
```

Ці приклади демонструють базову роботу з DOM в JavaScript, яка дозволяє маніпулювати структурою та змістом веб-сторінок, забезпечуючи динамічну інтерактивність із вмістом сторінки.

### Атрибути та властивості

У DOM (Document Object Model) HTML документа існують поняття атрибутів і властивостей, які використовуються для звертання до елементів та їх атрибутів через JavaScript. Ось короткий огляд цих понять та їх використання з прикладами коду:

#### Атрибути

Атрибути в HTML є частиною розмітки і задають додаткові властивості елементів. Вони описують стартовий стан елемента або зовнішній вигляд, а також змінюються відповідно до змін у розмітці HTML.

Приклади атрибутів у HTML:
```html
<a href="https://example.com">Посилання на приклад</a>
<input type="text" id="username" name="username">
<img src="image.jpg" alt="Зображення">
```

#### Властивості

Властивості (properties) в DOM представляють динамічні характеристики HTML елементів, до яких можна звертатися і змінювати їх за допомогою JavaScript. Вони дозволяють отримувати доступ до стану та поведінки елемента під час виконання програми.

Приклади властивостей у JavaScript:
```javascript
const link = document.getElementById('myLink');
console.log(link.href); // Властивість href
const input = document.getElementById('username');
console.log(input.value); // Властивість value
const image = document.querySelector('img');
console.log(image.src); // Властивість src
```

#### Різниця між атрибутами та властивостями

1. **Атрибути** відображають те, що написано у вихідному HTML. Вони задають початкові значення елементів і використовуються для визначення статичних характеристик, які не змінюються під час виконання.
   
2. **Властивості** представляють поточний стан елементів в DOM. Вони дозволяють отримати доступ до актуальних значень, встановлених в момент виконання JavaScript, і можуть бути змінені або оновлені в реальному часі.

Наприклад, зміна властивості `value` у полі введення (input) автоматично змінює вміст, який користувач бачить у полі, тоді як зміна атрибута `value` у HTML розмітці не змінює вміст поля вводу, поки не буде оновлено властивість `value`.

Це дозволяє JavaScript динамічно змінювати структуру та зовнішній вигляд веб-сторінок, забезпечуючи інтерактивність із вмістом на основі подій і взаємодії користувача.


### Внесення змін в документ DOM в JavaScript

Внесення змін в документ DOM (Document Object Model) у JavaScript полягає у маніпулюванні елементами, їхніми властивостями та вмістом, що дозволяє динамічно змінювати структуру та вигляд веб-сторінки. Нижче розглянемо основні методи та приклади внесення змін в DOM.

#### Основні методи для внесення змін в DOM:

1. **Вибір елементів**: Щоб внести зміни, перше, що потрібно зробити - це вибрати один або кілька елементів у DOM. Це можна зробити за допомогою методів `getElementById`, `getElementsByClassName`, `getElementsByTagName`, `querySelector` і `querySelectorAll`.

   ```javascript
   // Приклад вибору елемента за його ідентифікатором
   const header = document.getElementById('header');
   ```

2. **Зміна властивостей і атрибутів елементів**: Для зміни властивостей і атрибутів елементів використовуються властивості JavaScript або методи, такі як `setAttribute`.

   ```javascript
   // Зміна текстового вмісту елемента
   header.textContent = 'Новий текст заголовка';

   // Зміна класу елемента
   header.classList.add('new-class');

   // Зміна атрибуту
   header.setAttribute('title', 'Новий заголовок');
   ```

3. **Створення нових елементів**: Для створення нових елементів використовується метод `createElement`, після чого вони можуть бути додані до документу за допомогою методів `appendChild`, `insertBefore`, `insertAdjacentHTML` тощо.

   ```javascript
   // Створення нового елемента <p>
   const paragraph = document.createElement('p');
   paragraph.textContent = 'Це новий абзац';

   // Додавання нового елемента до документу
   document.body.appendChild(paragraph);
   ```

4. **Видалення елементів**: Для видалення елементів з DOM використовується метод `removeChild` або `remove`.

   ```javascript
   // Видалення елемента
   document.body.removeChild(paragraph);
   ```

#### Приклади внесення змін в документ DOM

```javascript
// Зміна текстового вмісту елемента з ідентифікатором "header"
const header = document.getElementById('header');
header.textContent = 'Новий текст заголовка';

// Створення нового елемента <p> та його додавання до документу
const paragraph = document.createElement('p');
paragraph.textContent = 'Це новий абзац';
document.body.appendChild(paragraph);

// Додавання класу до створеного абзацу
paragraph.classList.add('highlight');

// Видалення елемента з класом "highlight" з документу
const highlightedParagraph = document.querySelector('.highlight');
highlightedParagraph.remove();
```

Ці приклади демонструють базові прийоми внесення змін в документ DOM за допомогою JavaScript. Це дозволяє створювати динамічні інтерфейси, реагувати на події користувачів та оновлювати вміст сторінки у реальному часі.

### Стилі та класи в DOM в JavaScript

Взаємодія зі стилями і класами в DOM (Document Object Model) у JavaScript дозволяє динамічно змінювати вигляд елементів на сторінці. Нижче розглянемо основні методи роботи зі стилями і класами.

#### Зміна стилів елементів

Для зміни стилів елементів використовується властивість `style`. Ця властивість дає доступ до всіх CSS властивостей елемента.

```javascript
// Отримання елемента за його ідентифікатором
const element = document.getElementById('myElement');

// Зміна стилю за допомогою властивості style
element.style.color = 'red';
element.style.fontSize = '20px';
```

#### Додавання і видалення класів

Класи використовуються для зручного застосування груп стилів до елементів. Для додавання і видалення класів використовуються методи `classList.add` і `classList.remove`.

```javascript
// Отримання елемента за його класом
const element = document.querySelector('.myClass');

// Додавання класу до елемента
element.classList.add('highlight');

// Видалення класу з елемента
element.classList.remove('myClass');
```

#### Перевірка наявності класу

Метод `classList.contains` дозволяє перевірити, чи містить елемент певний клас.

```javascript
// Перевірка наявності класу на елементі
const element = document.getElementById('myElement');
if (element.classList.contains('highlight')) {
    console.log('Елемент містить клас highlight');
} else {
    console.log('Елемент НЕ містить клас highlight');
}
```

#### Динамічні зміни стилів і класів

```javascript
// Отримання елемента за його класом
const element = document.querySelector('.myElement');

// Зміна стилів
element.style.backgroundColor = 'lightblue';

// Додавання і видалення класів
element.classList.add('bigFont');
element.classList.remove('smallFont');
```

Ці приклади показують, як можна застосовувати стилі та класи динамічно в JavaScript для зміни вигляду елементів на сторінці. Це дозволяє створювати інтерактивні інтерфейси, які реагують на дії користувачів або на події.

### Події в JavaScript: Бульбашковий механізм (спливання та занурення)

Події (events) в JavaScript дозволяють відстежувати різноманітні дії користувачів на веб-сторінці, такі як кліки мишею, натискання клавіш, зміни розміру вікна тощо. Вони також мають свою структуру та особливості, пов'язані з механізмом спливання та занурення.

#### Бульбашковий механізм (Event Bubbling)

Бульбашковий механізм (Event Bubbling) означає, що коли відбувається подія на елементі, яка має батьківські елементи, ця подія спочатку спрацьовує на самому вкладеному елементі, а потім піднімається вгору по ієрархії до батьківських елементів.

Наприклад, якщо у нас є така HTML-структура:

```html
<div id="outer">
  <div id="middle">
    <div id="inner">Click me!</div>
  </div>
</div>
```

Та JavaScript-код для обробки кліків на цих елементах:

```javascript
document.getElementById('outer').addEventListener('click', function() {
  console.log('Outer div clicked');
});

document.getElementById('middle').addEventListener('click', function() {
  console.log('Middle div clicked');
});

document.getElementById('inner').addEventListener('click', function() {
  console.log('Inner div clicked');
});
```

Якщо користувач клікне на елемент з id `inner`, спочатку буде викликано обробник для цього елемента, потім для елементу з id `middle` і нарешті для елементу з id `outer`. Це дозволяє обробляти події на різних рівнях ієрархії елементів.

#### Зупинка спливання подій (Event Propagation)

Іноді необхідно зупинити спливання подій, щоб певні обробники не викликались. Це можна зробити за допомогою методу `stopPropagation()` у події.

```javascript
document.getElementById('inner').addEventListener('click', function(event) {
  console.log('Inner div clicked');
  event.stopPropagation(); // Зупиняємо спливання події
});
```

У цьому прикладі, якщо користувач клікне на елемент з id `inner`, буде викликано тільки обробник для цього елемента, а інші не будуть викликані через `stopPropagation()`.

#### Захоплення подій (Event Capturing)

За умовчанням, події спочатку спливають вгору (бульбашковий механізм), але також існує можливість захопити подію на фазі захоплення (capturing phase), коли вона ще не дійшла до цільового елемента. Це досягається встановлення третього параметра `true` у методі `addEventListener`.

```javascript
document.getElementById('outer').addEventListener('click', function() {
  console.log('Outer div clicked');
}, true); // Третій параметр true для захоплення події

document.getElementById('middle').addEventListener('click', function() {
  console.log('Middle div clicked');
}, true);

document.getElementById('inner').addEventListener('click', function() {
  console.log('Inner div clicked');
}, true);
```

У цьому випадку події спочатку будуть оброблені на фазі захоплення (зверху до низу), а потім на фазі спливання (знизу до верху).

#### Використання бульбашкового механізму для взаємодії з DOM

Бульбашковий механізм (спливання та занурення) використовується для створення складних інтерфейсів, де обробка подій може бути налаштована на різних рівнях ієрархії DOM. Він дозволяє ефективно реагувати на дії користувачів і керувати їхніми наслідками у веб-додатках.

### Делегування подій в JavaScript

Делегування подій є потужним підходом в обробці подій в JavaScript, який дозволяє ефективно керувати обробкою подій для багатьох елементів з допомогою одного обробника на їхньому спільному батьківському елементі. Це особливо корисно для динамічно створених елементів або для оптимізації коду.

#### Як працює делегування подій

Основна ідея полягає в тому, що ми прикріплюємо один обробник подій до батьківського елемента і за допомогою механізму спливання подій визначаємо цільовий елемент, на якому відбулася подія.

#### Приклад делегування кліків для списку елементів

HTML-структура:

```html
<ul id="myList">
  <li>Елемент 1</li>
  <li>Елемент 2</li>
  <li>Елемент 3</li>
</ul>
```

JavaScript для делегування кліків на елементи списку:

```javascript
// Отримуємо батьківський елемент списку
const myList = document.getElementById('myList');

// Додаємо обробник подій до батьківського елемента
myList.addEventListener('click', function(event) {
  // Визначаємо цільовий елемент, на якому відбулася подія кліку
  const target = event.target;

  // Перевіряємо, чи клікнули на елемент <li>
  if (target.tagName.toLowerCase() === 'li') {
    console.log('Клікнуто на елемент з текстом: ' + target.textContent);
    // Додаткові дії з цільовим елементом
  }
});
```

У цьому прикладі ми додаємо один обробник подій до елемента `<ul>` (списку). Коли користувач клікає на будь-який елемент `<li>` у списку, подія кліку спочатку спливає вгору до елемента `<ul>`. Ми перевіряємо, чи цільовий елемент, на якому відбулася подія (`event.target`), є елементом `<li>`, і якщо так, обробляємо подію.

#### Переваги делегування подій

- **Ефективність**: Замість додавання обробників для кожного окремого елемента, ми використовуємо лише один обробник для батьківського елемента.
  
- **Динамічність**: Якщо елементи додаються або видаляються з DOM динамічно, делегування подій автоматично застосовується до нових елементів без необхідності зміни коду.

- **Зменшення коду**: Код стає більш компактним і легше керованим.

Делегування подій є потужним інструментом в розробці веб-додатків, який дозволяє підтримувати чистоту коду і забезпечує ефективне використання ресурсів браузера.

### Типові дії браузера

Типові дії браузера включають широкий спектр подій та взаємодій, які користувач може виконувати під час перегляду веб-сторінок. Нижче розглянемо деякі з найбільш поширених типових дій:

1. **Клік (click)**:
   - **Опис**: Користувач клікає на елемент сторінки за допомогою лівої кнопки миші.
   - **Використання**: Виклик функцій або методів, зміна стану сторінки, відкриття посилань або елементів інтерфейсу.

2. **Подвійний клік (dblclick)**:
   - **Опис**: Користувач швидко двічі клікає на елемент сторінки за допомогою лівої кнопки миші.
   - **Використання**: Зазвичай використовується для подвійного кліку на тексті для виділення, або на елементах, які відкривають додаткові вікна або функції.

3. **Наведення курсору (mouseover)**:
   - **Опис**: Курсор миші вказує на елемент сторінки.
   - **Використання**: Зазвичай використовується для зміни вигляду елементу при наведенні, наприклад, підсвічування, зміна кольору або відображення додаткових даних.

4. **Фокус (focus) і зняття фокусу (blur)**:
   - **Опис**: Користувач переходить на елемент і віддає йому фокус (або втрачає фокус).
   - **Використання**: Введення даних в форми, активація певних функцій або взаємодія з клавіатурою.

5. **Введення тексту (input)**:
   - **Опис**: Користувач вводить текст у текстові поля або інші відповідні елементи.
   - **Використання**: Оновлення даних у реальному часі, перевірка форматування або дозволення користувачу вводити інформацію.

6. **Натискання клавіші (keydown, keyup)**:
   - **Опис**: Користувач натискає на клавішу на клавіатурі.
   - **Використання**: Зчитування введеного тексту, навігація між елементами або виконання певних дій при певних комбінаціях клавіш.

7. **Коліщатко миші (mousewheel)**:
   - **Опис**: Користувач прокручує коліщатко миші вгору або вниз.
   - **Використання**: Прокручування вмісту сторінки, зміна значень у віджетах, таких як слайдери або списки.

Ці типові дії є основою взаємодії користувача з веб-сторінками і дозволяють створювати багатофункціональні та відзначені візуально інтерфейси для ефективної навігації та обробки інформації.

### Запуск користувацьких подій в JavaScript

Запуск користувацьких подій (custom events) в JavaScript дозволяє створювати та спровоковувати власні події, які можуть бути оброблені згідно з потребами програми. Це корисний підхід для організації взаємодії між різними частинами програми чи бібліотеками.

#### Створення користувацької події

Для створення користувацької події використовується клас `CustomEvent`. При створенні події можна вказати тип події та додаткові дані, які можуть передаватися разом з подією.

```javascript
// Створення нової користувацької події з типом "customEvent"
const customEvent = new CustomEvent('customEvent', {
  detail: {
    message: 'Це користувацька подія!'
  }
});

// Диспетчеризація (запуск) події на документі або конкретному елементі
document.dispatchEvent(customEvent);
```

#### Обробка користувацької події

Після того як користувацька подія створена і запущена, її можна перехопити та обробити на потрібних елементах або на документі за допомогою методу `addEventListener`.

```javascript
// Обробник для користувацької події
function handleCustomEvent(event) {
  console.log('Отримано користувацьку подію!');
  console.log(event.detail.message); // Виводимо повідомлення з деталями події
}

// Додаємо обробник події до документу
document.addEventListener('customEvent', handleCustomEvent);
```

У цьому прикладі ми створюємо користувацьку подію з типом `customEvent` та передаємо додаткові дані через властивість `detail`. Після цього ми додаємо обробник для цієї події, який виводить повідомлення в консоль.

#### Використання користувацьких подій

Користувацькі події дозволяють структурувати код, роблять його більш зрозумілим та дозволяють ефективно комунікувати між різними частинами програми або між компонентами. Вони особливо корисні в архітектурі програм з подійною моделлю, де взаємодія між елементами часто відбувається через відправку та обробку подій.

За допомогою користувацьких подій можна легко і гнучко організувати взаємодію між компонентами веб-додатка та додавати нові функціональні можливості до програмного забезпечення.

### Події миші в JavaScript

Події миші в JavaScript використовуються для відстеження дій користувача з мишею на веб-сторінці. Вони дозволяють реагувати на кліки, подвійні кліки, наведення курсору та інші взаємодії. Нижче розглянемо основні події миші та їх використання.

#### Основні події миші

1. **Клік (click)**:
   - **Опис**: Виникає при натисканні лівої кнопки миші на елементі.
   - **Використання**: Виконання певних дій при кліку на кнопки, посилання, чи інші елементи.

```javascript
element.addEventListener('click', function(event) {
  console.log('Клікнуто на елемент');
});
```

2. **Подвійний клік (dblclick)**:
   - **Опис**: Виникає при подвійному натисканні лівої кнопки миші на елементі.
   - **Використання**: Виконання дій, які потребують подвійного кліку для активації, наприклад, відкриття деталей або редагування елементів.

```javascript
element.addEventListener('dblclick', function(event) {
  console.log('Подвійний клік на елементі');
});
```

3. **Наведення курсору (mouseover, mouseout)**:
   - **mouseover**: Виникає коли курсор миші переходить на елемент.
   - **mouseout**: Виникає коли курсор миші покидає елемент.

```javascript
element.addEventListener('mouseover', function(event) {
  console.log('Курсор миші наведено на елемент');
});

element.addEventListener('mouseout', function(event) {
  console.log('Курсор миші покинув елемент');
});
```

4. **Натискання кнопки миші (mousedown, mouseup)**:
   - **mousedown**: Виникає при натисканні будь-якої кнопки миші (ліва, права або середня).
   - **mouseup**: Виникає після відпускання кнопки миші після натискання.

```javascript
element.addEventListener('mousedown', function(event) {
  console.log('Кнопка миші натиснута');
});

element.addEventListener('mouseup', function(event) {
  console.log('Кнопка миші відпущена');
});
```

5. **Прокрутка коліщатка миші (mousewheel, wheel)**:
   - **mousewheel**: Виникає при прокрутці коліщатка миші (старе API, не рекомендоване).
   - **wheel**: Сучасне API для прокрутки коліщатка миші.

```javascript
element.addEventListener('wheel', function(event) {
  console.log('Прокручено коліщатко миші');
});
```

#### Використання подій миші

Події миші дозволяють створювати інтерактивні елементи і інтерфейси, які реагують на дії користувача. Вони є важливою частиною розробки веб-додатків, особливо коли потрібно взаємодіяти зі складними елементами або анімаціями. За допомогою подій миші можна легко контролювати та обробляти користувацькі дії на сторінці.


### Клавіатурні події: keydown та keyup

Клавіатурні події `keydown` та `keyup` використовуються для відслідковування натискання та відпускання клавіш на клавіатурі веб-сторінки. Вони дозволяють реагувати на введення користувача через клавіатуру та виконувати відповідні дії в програмах чи веб-додатках.

#### Основні клавіатурні події

1. **keydown**:
   - **Опис**: Подія спрацьовує, коли користувач натискає на клавішу.
   - **Використання**: Зазвичай використовується для зчитування введеного тексту, навігації між елементами або виконання певних дій при певних комбінаціях клавіш.

   ```javascript
   document.addEventListener('keydown', function(event) {
     console.log('Натиснуто клавішу: ' + event.key);
   });
   ```

2. **keyup**:
   - **Опис**: Подія спрацьовує, коли користувач відпускає клавішу.
   - **Використання**: Зазвичай використовується для обробки дій після того, як користувач відпустив клавішу, таких як зміна стану або виконання певних дій.

   ```javascript
   document.addEventListener('keyup', function(event) {
     console.log('Відпущено клавішу: ' + event.key);
   });
   ```

#### Використання клавіатурних подій

Клавіатурні події дозволяють створювати інтерактивні елементи, які реагують на введення користувача через клавіатуру. Вони дозволяють зручно керувати взаємодією користувача з веб-додатком або веб-сайтом, зчитувати введений текст, контролювати навігацію та виконувати інші дії відповідно до потреб додатка.

Клавіатурні події особливо корисні для створення ігор, веб-редакторів, форм, де потрібно контролювати введений текст або виконувати дії за допомогою спеціальних клавішних комбінацій.


## Властивості та методи форми в JavaScript

Форма в HTML представляє собою елемент, який збирає введені користувачем дані і передає їх на сервер для обробки. В JavaScript доступ до форми здійснюється через об'єкт `HTMLFormElement`. Розглянемо основні властивості та методи цього об'єкта:

### Властивості форми

1. **elements**: Повертає колекцію елементів форми (таких як input, select, textarea).

   ```javascript
   const form = document.querySelector('form');
   const elements = form.elements;
   ```

2. **length**: Повертає кількість елементів у формі.

   ```javascript
   const form = document.querySelector('form');
   const numberOfElements = form.length;
   ```

3. **name**: Повертає атрибут `name` форми.

   ```javascript
   const form = document.querySelector('form');
   const formName = form.name;
   ```

4. **action**: Повертає атрибут `action`, який вказує URL або шлях для обробки даних форми.

   ```javascript
   const form = document.querySelector('form');
   const formAction = form.action;
   ```

5. **method**: Повертає атрибут `method`, який вказує HTTP метод (GET або POST) для відправки даних форми.

   ```javascript
   const form = document.querySelector('form');
   const formMethod = form.method;
   ```

### Методи форми

1. **submit()**: Відправляє форму на сервер для обробки.

   ```javascript
   const form = document.querySelector('form');
   form.submit();
   ```

2. **reset()**: Скидає всі елементи форми до їх початкових значень.

   ```javascript
   const form = document.querySelector('form');
   form.reset();
   ```

### Приклад роботи з формою в JavaScript

```html
<form id="myForm" action="/submit" method="post">
  <label for="name">Ім'я:</label>
  <input type="text" id="name" name="name"><br><br>
  <label for="email">Email:</label>
  <input type="email" id="email" name="email"><br><br>
  <button type="submit">Відправити</button>
  <button type="button" onclick="resetForm()">Скинути</button>
</form>

<script>
  function resetForm() {
    const form = document.getElementById('myForm');
    form.reset();
  }
</script>
```

У цьому прикладі ми маємо форму з двома текстовими полями і двома кнопками. JavaScript використовується для збору даних з форми та виклику методу `reset()`, щоб скинути значення полів до початкових.

Це лише основа роботи з формами в JavaScript. Залежно від потреб вашого додатку або веб-сайту, можуть використовуватися додаткові методи та властивості для отримання і обробки даних форми.

### Важливі події життєвого циклу сторінки в браузері

У веб-розробці існує кілька ключових подій, які відображають різні етапи життєвого циклу сторінки в браузері. Кожна з цих подій викликається автоматично браузером у відповідь на певну подію або стан сторінки. Розглянемо основні з них:

#### DOMContentLoaded

Подія `DOMContentLoaded` відбувається, коли структура DOM сторінки повністю завантажена і розібрана, без чекання на завантаження стилів, картинок та інших ресурсів. Це дозволяє запускати скрипти, які маніпулюють DOM або взаємодіють з елементами сторінки.

```javascript
document.addEventListener('DOMContentLoaded', function(event) {
  console.log('DOM fully loaded and parsed');
});
```

#### load

Подія `load` спрацьовує, коли всі ресурси сторінки (DOM, стилі, зображення, скрипти) повністю завантажені.

```javascript
window.addEventListener('load', function(event) {
  console.log('Страниця та всі ресурси завантажені');
});
```

#### beforeunload

Подія `beforeunload` виникає, коли користувач підготовлюється покинути сторінку. Вона дозволяє відобразити спливаюче вікно для підтвердження дії або збереження даних перед виходом зі сторінки.

```javascript
window.addEventListener('beforeunload', function(event) {
  // Повертаємо значення, яке використовується браузером у спливаючому вікні
  event.returnValue = 'Ви впевнені, що хочете покинути цю сторінку?';
});
```

#### unload

Подія `unload` спрацьовує, коли користувач покидає сторінку. Вона викликається після того, як користувач вже вирішив покинути сторінку, але до того, як сторінка буде фактично видалена з пам'яті браузера.

```javascript
window.addEventListener('unload', function(event) {
  console.log('Страниця покинута, ресурси вивантажені');
});
```

Ці події дозволяють веб-розробникам ефективно керувати життєвим циклом сторінки і виконувати певні дії на кожному з етапів завантаження, перевірки перед виходом або після завершення використання сторінки.

### Скрипти: async та defer

У HTML є два атрибути для скриптів - `async` та `defer`, які впливають на те, коли і як скрипти завантажуються і виконуються в процесі завантаження сторінки. Розглянемо їх особливості:

#### async

Атрибут `async` дозволяє браузеру завантажувати скрипт асинхронно, тобто без зупинки завантаження сторінки і виконується скрипт, як тільки він завантажиться.

```html
<script src="script.js" async></script>
```

Особливості `async`:

- Скрипт завантажується паралельно з іншими ресурсами сторінки.
- Виконання скрипта починається, як тільки він завантажений, незалежно від того, чи завантажено інші ресурси чи ні.
- Порядок виконання скриптів з атрибутом `async` не гарантується, тому скрипти з цим атрибутом не мають взаємної залежності.

#### defer

Атрибут `defer` також дозволяє завантажувати скрипт асинхронно, але з гарантією, що вони будуть виконані в тому порядку, в якому вони зустрічаються у HTML.

```html
<script src="script.js" defer></script>
```

Особливості `defer`:

- Скрипт завантажується паралельно з іншими ресурсами сторінки.
- Виконання скрипта розпочнеться тільки після того, як сторінка буде повністю завантажена.
- Скрипти з атрибутом `defer` виконуються в тому порядку, в якому вони зустрічаються в HTML документі.

#### Вибір між async та defer

- Використовуйте `async`, якщо ваш скрипт не залежить від інших скриптів або DOM, і його можна виконати якомога швидше.
- Використовуйте `defer`, якщо ваш скрипт залежить від інших скриптів або DOM, або якщо ви хочете зберегти порядок виконання скриптів.

Ці атрибути дозволяють збалансувати швидкість завантаження сторінки з потребою в правильному порядку виконання скриптів, що є важливим для правильної роботи веб-додатків та сайтів.

### Завантаження ресурсів: onload та onerror

У веб-розробці для взаємодії з завантаженням ресурсів (таких як зображення, скрипти, стилі) використовуються події `onload` і `onerror`, які дозволяють вам відслідковувати успіх або невдачу завантаження ресурсу.

#### onload

Подія `onload` спрацьовує, коли ресурс (зображення, скрипт, аудіо, відео тощо) повністю завантажений і готовий до використання.

```javascript
const image = new Image();
image.onload = function() {
  console.log('Зображення успішно завантажене');
};
image.src = 'image.jpg';
```

В контексті HTML:

```html
<img src="image.jpg" onload="console.log('Зображення успішно завантажене')">
```

#### onerror

Подія `onerror` викликається, коли ресурс не вдалося завантажити (наприклад, через неправильне посилання або проблеми з мережею).

```javascript
const image = new Image();
image.onerror = function() {
  console.error('Помилка завантаження зображення');
};
image.src = 'nonexistent.jpg'; // Неправильний URL
```

В контексті HTML:

```html
<img src="nonexistent.jpg" onerror="console.error('Помилка завантаження зображення')">
```

#### Використання подій onload та onerror

- **onload**: Використовуйте для виконання дій після успішного завантаження ресурсу, наприклад, для відображення зображення, запуску скрипта чи анімації.
- **onerror**: Використовуйте для обробки помилок під час завантаження ресурсу, щоб інформувати користувача або вжити необхідні заходи для відновлення роботи.

Ці події дозволяють створювати більш інтерактивні і надійні веб-додатки, забезпечуючи контроль над завантаженням ресурсів і відповідне реагування на помилки.

## Mutation Observer (спостерігач за мутаціями)
### Selection і Range
### Цикл подій (event loop): мікрозавдання (microtasks) та макрозавдання (macrotasks)

## Спливаючі вікна та методи window
## File та FileReader
### LocalStorage та sessionStorage

`LocalStorage` і `sessionStorage` - це два інтерфейси у веб-браузері, які дозволяють зберігати дані на клієнтському боці (на боці користувача) без необхідності надсилати їх на сервер. Ці механізми зберігають дані у вигляді пар ключ-значення, і кожен з них має свої особливості.

#### LocalStorage

`LocalStorage` зберігає дані без терміну дії, тобто дані не видаляються при закритті вкладки чи браузера і залишаються доступними, поки їх не видалить користувач або не буде очищений кеш браузера.

##### Основні методи та властивості LocalStorage:

- **setItem(key, value)**: Зберігає пару ключ-значення в LocalStorage.
  
  ```javascript
  localStorage.setItem('username', 'john_doe');
  ```

- **getItem(key)**: Отримує значення з LocalStorage за ключем.

  ```javascript
  const username = localStorage.getItem('username');
  console.log(username); // виведе "john_doe"
  ```

- **removeItem(key)**: Видаляє запис з LocalStorage за ключем.

  ```javascript
  localStorage.removeItem('username');
  ```

- **clear()**: Очищає усі дані з LocalStorage.

  ```javascript
  localStorage.clear();
  ```

#### sessionStorage

`SessionStorage` схожий на `LocalStorage`, але зберігає дані тільки під час одного сеансу браузера (сесії). Як тільки користувач закриває вкладку чи браузер, дані в `sessionStorage` видаляються.

##### Основні методи та властивості sessionStorage:

- **setItem(key, value)**: Зберігає пару ключ-значення в sessionStorage.
  
  ```javascript
  sessionStorage.setItem('token', 'abc123');
  ```

- **getItem(key)**: Отримує значення з sessionStorage за ключем.

  ```javascript
  const token = sessionStorage.getItem('token');
  console.log(token); // виведе "abc123"
  ```

- **removeItem(key)**: Видаляє запис з sessionStorage за ключем.

  ```javascript
  sessionStorage.removeItem('token');
  ```

- **clear()**: Очищає усі дані з sessionStorage.

  ```javascript
  sessionStorage.clear();
  ```

#### Використання LocalStorage та sessionStorage

Ці інтерфейси корисні для зберігання даних, які потрібні на стороні клієнта, наприклад, для зберігання налаштувань, кешування даних або тимчасових сесійних даних. Вони забезпечують зручний спосіб доступу до даних без необхідності використання серверних запитів, що покращує продуктивність і швидкість веб-додатків.